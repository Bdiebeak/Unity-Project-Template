# Unity-Project-Template

# ДИСКЛЕЙМЕР

Данный текст и реализация шаблонного проекта основана на моем личном опыте. Я пишу это по большей части для себя и своего портфолио, но если кому-то пригодится, буду только рад. Не судите строго.  
Данный репозиторий можно назвать готовым шаблоном для начала разработки нового проекта. Я уделил большое количество времени документации, так как планирую создать из нее некую базу моих личных знаний, к которой всегда можно будет вернуться и освежить свою память.

# О ШАБЛОНЕ

## TODO

- [ ] Перевод на английский
- [ ] Полезная кодовая база в виде .unitypackages
- [ ] Пару проектов-примеров на основе данного шаблона
- [ ] Сделать удобную тулзу для настройки проекта

## Затронутые элементы

- Подготовлена иерархия папок проекта для удобной работы;
- Настроена точка входа в проект и порядок его инициализации;
- Заранее подключены плагины для работы с DI (Zenject) и асинхронными операциями (UniTask);
- Реализовано начальное разделение проекта на сборки (Assembly Definitions);

## Иерархия папок

Важно разделять каждую из частей проекта между собой и не смешивать их. Для реализации подобной идеи лучше всего создать следующую иерархию:

>- **Backend** - код бэкенда
>	- ...
>- **Frontend** - код фронтенда
>	- **Assets**
>		- **\_Local** - локальная папка, которая хранит содержимое локально, не добавляя в систему управления версиями
>		- **Art** - папка с графическими элементами
>			- **Materials**
>			- **Models**
>			- **Shaders**
>			- **Sprites**
>			- **Textures**
>		- **Scripts** - папка для кода проекта
>			- **Editor** - эдитор скрипты
>			- **Runtime** - скрипты, которые используется в момент работы приложения
>				- **Meta** - мета часть приложения и по сути все UI меню
>				- **Core/Game** - лучше использовать Core, т.к. в Unity не обязательно создается игра и кому-то такое название может не подойти
>			- **Infrastructure** - сервисы и прочие общие вещи для проекта
>				- **Constants** - константы проекта
>				- **Services** - сервисы проекта (сохранения, конфиги и т.п.)
>				- **Utilities** - классы расширений
>		- **Settings** - настройки проекта (настройки света, пресеты импорта и т.п.)
>		- **...**
>- **Shared** - общий код между фронтендом и бэкендом (модели, ответы, запросы и т.п.)

При использовании такого подхода папки Backend, Shared и Frontend могут быть отдельными репозиториями, а папка Shared, например, подключаться к проекту в виде сабмодуля.  
Многие стараются избегать использование сабмодулей, так как не каждый git-клиент умеет с ними работать. Лично я использую GitKraken и его функционала достаточно для успешной и удобной работы.  
Хорошей практикой является выделение папки с файлами проекта в отдельную, так как со временем проект обрастает сторонними плагинами и SDK, а папка Assets становится заполненной. Из-за этого поиск нужных файлов затрудняется. К тому же, при наличии подобной папки IDE сможет автоматически проставить верные namespaces.

## Точка входа

Для лучшего понимания проекта необходимо иметь единую точку входа не только в самом проекте, но и на сцене или даже объекте (причем на каждом). При выяснении алгоритма работы какой-либо части проекта важно знать, откуда именно эта часть начинает свое выполнение, какие зависимости она требует и что делает дальше.

Можно выделить следующие точки входа:
- **У проекта** - папка Project;
- **У сцены** - EntryPoint-объект с инициализацией и регистрацией зависимостей;
- **У объекта** - главный скрипт, который желательно разместить первым в иерархии для удобства чтения;

Подобная архитектура поможет не только лучше понимать проект, но и удобнее взаимодействовать с ним. Вы точно понимаете в каком месте создавать и настраивать объекты.

## Зависимости и DI

Зависимость - это связь между несколькими элементами, при которой один из них (класс А) нуждается в услугах другого (класс Б). В таком случае говорят, что класс А зависит от класса Б.

Зависимости бывают:
- **Явные** - можно сказать, что это зависимости из конструктора, так как при первом просмотре класса их явно видно из интерфейса. Это позволяет лучше контролировать сложность объекта, понимать его работу и следовать `SRP`;
- **Неявные** - зависимости, которые используются внутри кода, но при первом просмотре на них можно не обратить внимания. Такие зависимости появляются из-за использования статических классов или создания новых с помощью оператора new;

Чем поможет DI?
- Перенести создание зависимостей на другой слой, добавляя возможность управления реализацией, зоной и временем жизни. Это позволяет отделять код создания объектов от бизнес-логики и легко заменить зависимость на другую реализацию при необходимости;
- Правильно реализовать программный код с точкой входа, о которой я говорил выше;
- Избавиться от состояния гонки путем разделения инициализации и начала работы;
- Избежать неявных зависимостей внутри класса;
- Ну и очевидное: автоматически внедрять зависимости, упростить создание зависимостей в тестах, облегчить поддержку кода;

Стоит помнит несколько простых правил:
- Хорошая функция получает свои зависимости через аргументы, а хороший класс - через конструктор;
- Конструктор не должен включать в себя логику, только инициализацию зависимостей;
- Зависимости должны быть на абстракциях, а не на реализациях, следовать `DIP`;

В данном шаблоне в качестве DI библиотеки я решил использовать `Zenject`, т.к. на данный момент он является базой индустрии.

## Готовые сцены

В проекте есть заранее подготовленные сцены. Каждая из них нужна для выполнения определенных действий.  
- **Bootstrap** - точка входа и начальная сцена проекта. Нужна для инициализации и загрузки глобальных составляющих, которые могут быть использованы из любого места проекта. Например: загрузка конфигов, подключение аналитики, проверка версии и т.п;
- **Meta** - основные элементы мета-составляющей игры. Мета-геймплей, главное меню и весь остальной UI, который не включает в себя игровой процесс;
- **Core** - основная часть игры, которая включает в себя реиграбельную логику;
- **Empty** - сцена для выгрузки ресурсов и выгрузки всех составляющих предыдущих сцен;

Конечно, проект может содержать и другие сцены, например, сцены дополнительных уровней. Их лучше всего подгружать с открытой Core сценой в виде дополнительных сцен. 

## Готовые пакеты

Я не хотел заполнять этот проект готовыми сэмплами кода, так как какой-то функционал банально может не пригодиться и будет просто мозолить глаза. А может и вовсе заставит использовать то, что изначально не планировалось, постоянно надоедая своим присутствием. Иногда гораздо быстрее и правильнее реализовать какой-то простой функционал заново, ограничивая код текущими нуждами проекта. На это есть еще несколько причин:
1) Повторение - мать учения;
2) Мы становимся лучше с каждым днем, а следовательно и наш код. Хороший повод переписать что-то старое с обновленными знаниями;

- [ ] TODO Но все же я решил подготовить такой код. Скоро он появится здесь.

# ПОЛЕЗНЫЕ ПРАКТИКИ

## Работа с проектом

На мой взгляд, работа с проектом при разработке какого-либо приложения должна выглядеть как конструктор - итоговый продукт должен легко собираться из различных модулей.  
Чтобы работа была более приятной и менее болезненной, я приведу список некоторых практик, которые полезно соблюдать.

- **Ведение репозитория**  
Ведение репозитория должно быть прозрачным, понятным, разделенным на конкретные стадии разработки. Имена коммитов должны четко говорить о том, что было изменено/добавлено в нем.  
Принято выделять несколько основных веток при ведении репозитория:
  - **Main** - главная ветка проекта. В каких-то проектах пустая, в каких-то ее версия соответствует последней версии билда - решать вам. Настроено релизное окружение;
  - **Develop** - основная ветка разработки. Законченные задачи добавляются в нее. Настроено тестовое окружение;
  - **Production** - ветка, включающая в себя готовые задачи для следующего релиза. Настроено релизное окружение;
  - **Art** - отдельная ветка для работы графических дизайнеров и не программистов;
  - **Features** - это скорее совокупность веток. В ней разработчики создают новую ветку под каждую новую задачу. Если в проекте используется какая-нибудь система таск-трекинга,  название ветки может включать в себя номер задачи. Например: `features/11-player-movement`.

- **Логи**  
Важно покрывать логами как можно большую часть программного кода. Это поможет выявить странное и некорректное поведение, оптимизировать приложение и, конечно же, вовремя заметить баг. Может быть полезно разделение логов на фичи, чтобы легче было отфильтровать их и выключить по необходимости.
Например: `[02-02-24 17:19:29] [WEAPONS]: Damage 15.`

- **Параллельная работа**  
Стоит избегать конфликтов. Я имею ввиду конфликты, связанные с работой контроля версий, но и на личные не стоит тратить время и нервы. Для уменьшения количества конфликтов во время работы нужно пытаться максимально декомпозировать префабы при параллельной работе и по возможности инициализировать все из кода, т.к. конфликты в коде гораздо проще решаемы.
 
- **Регулярный профайлинг и тестирование**  
Профайлинг и тестирование приложения должны производиться на протяжении всего цикла разработки, начиная с самого раннего этапа. Нужно это для того, чтобы не запустить проект и не тратить бесконечное количество времени на его оптимизацию и оживление в дальнейшем. Желательно профайлить и тестировать каждую более менее большую фичу и делать это на разных платформах, с разным железом.

- **Составление списка задач**  
При разработке проекта стоит составлять список задач - будущих, активных, тестируемых и завершенных. А перед началом какой-то конкретной задачи стоит разбивать ее на этапы, если сама задача недостаточно декомпозирована. Это помогает понять, оценить все этапы работы и выявить проблемные места. При этом разработчик не будет тратить большое количество времени на обдумывание следующего шага, а просто перейдет к нему из заранее подготовленного списка задач.

- **Оверинжиниринг**  
Довольно часто разработчики начинают создавать большое количество ненужных на текущий момент вещей. Нужно двигаться от задачи и покрывать лишь ее требования, не усложняя и не увеличивая время на разработку того, что по итогу может не пригодиться. Если в задаче поставлена реализация чего-то конкретного, не нужно включать в нее что-либо еще.

## Работа с кодом

- **Единый код стайл**  
Советую договориться о конкретном стиле написания кода в команде. Это поможет улучшить читаемость проекта каждому разработчику.

- **Уважение чужого кода**  
Нужно уметь уважать чужой код. Не стоит изменять на свой лад каждый файл с кодом, который писали не вы. Тем более, если этот код работает. Вы рискуете сломать что-то и потратить много времени на переписывание уже готовой задачи. Единственное исключение - правки костылей.

- **Директивы**  
Defines помогают включать и отключать некоторый функционал проекта, который должен запускаться в том или ином окружении. Можно выделить два основных вида:
  - **Раздельные** - отключает конкретный функционал. Например, наличие `LOGS` в параметрах включает логи, а его отсутствие - отключает;
  - **Комбинированные** - отключает совокупность функционала. Например, наличие `PRODUCTION` отключает весь дебажный функционал;

- **Композиция**  
Избегайте больших цепочек наследования. Лучше воспользоваться композицией.
Композиция позволяет меньше зависеть от иерархии классов и легче менять структуру программы. Например, если вы используете наследование, то изменение базового класса может повлиять на все классы, наследующиеся от него. Кроме того, код становится удобнее читать - не нужно прыгать по большой цепочки наследования классов, чтобы понять что и как работает.

- **Сборки**  
Assembly Definitions лучше называть с припиской названия проекта (`ProjectName.Editor` и т.п.). Такой нейминг поможет избежать коллизии между сборками при импорте сторонних плагинов.

- **Тестирование**  
Тестирование - это, конечно, хорошо, но в реальности ему не всегда уделяют должное время. Если вы нашли время для написания тестов - это прекрасно. Старайтесь покрыть тестами как можно большую часть кода.

- **Константы**  
Не хардкодьте значения, особенно текст для UI. Лучше всего выносить константные значения: различные параметры и тем более строковые сообщения в отдельные места. Во-первых, это может помочь избежать дублирования кода, а во-вторых, облегчит жизни при добавлении в проект, например, локализации или удаленных конфигов.

# ПОЛЕЗНЫЕ ПЛАГИНЫ

Данный блок включает в себя плагины, которые я довольно часто использую в проектах.  
[Zenject](https://github.com/modesttree/Zenject) - DI контейнер. Своего рода стандарт индустрии, который используется в огромном количестве проектов для внедрения зависимостей.  
[VContainer](https://github.com/hadashiA/VContainer)- DI контейнер, который, по словам авторов, работает гораздо быстрее Zenject'a и не содержит сторонних вещей по типу Signals (из того же Zenject'a).  
[UniRX](https://github.com/neuecc/UniRx) - плагин для создания реактивных полей. Наиболее часто используется для оповещения UI об изменении моделей данных.  
[R3](https://github.com/Cysharp/R3) - улучшенный UniRX.  
[UniTask](https://github.com/Cysharp/UniTask) - стандарт индустрии для работы с async/await кодом в Unity.  
[DOTween](https://dotween.demigiant.com/) - стандарт индустрии для создания различных твинов анимаций, например в UI.  
[PrimeTween](https://github.com/KyryloKuzyk/PrimeTween) - аналог DOTween, который, по словам авторов, работает быстрее и создает меньше мусора, чем DOTween.  
[AsmdefHelper](https://github.com/naninunenoy/AsmdefHelper) - формирует граф зависимостей на основе существующих в проекте сборок.  
[DependenciesHunter](https://github.com/AlexeyPerov/Unity-Dependencies-Hunter) - помогает сформировать схему зависимостей внутри проекта, какие объекты используют тот или иной объект. Бывает полезно понять, кто конкретно использует данный асет и нужен ли он вообще в проекте.  
**NativePlugins** - нативные плагины для мобильных устройств с готовой реализаций функционала. Примеры: [NativeShare](https://github.com/yasirkula/UnityNativeShare), [NativeGallery](https://github.com/yasirkula/UnityNativeGallery).  
[Graphy](https://github.com/Tayx94/graphy) - плагин для отображения FPS и прочих ресурсов билда.  
[InGameDebugConsole](https://github.com/yasirkula/UnityIngameDebugConsole) - дебаг консоль для отображения логов игры и ввода определенных команд.  